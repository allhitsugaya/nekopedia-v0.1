import React from 'react';

const EventBubblingPage = () => {
    return (
        <div className="page-container">
            <h1>Механізм спливання та використання спливання подій</h1>

            <h2>Механізм спливання</h2>
            <p>
                Механізм спливання подій полягає в тому, що коли подія спрацьовує на конкретному елементі DOM, вона спочатку обробляється на цьому елементі, а потім починає підніматися вгору по ієрархії DOM. Під час підняття події кожен батьківський елемент також спрацьовує подію, якщо для нього був призначений відповідний обробник.
            </p>
            <p>
                Простими словами, коли подія відбувається на елементі, спочатку запускаються обробники на ньому, потім на його батькові, потім на інших предках і так до самого верху.
            </p>
            <p>
                Скажімо у нас є 3 вкладені елементи <code>FORM > DIV > P</code> з обробником на кожному з них:
            </p>
            <pre>
        <code>
          {`
<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
          `}
        </code>
      </pre>
            <p>
                При кліку на внутрішній <code>&lt;p&gt;</code> спочатку виконується <code>onclick</code>:
            </p>
            <ul>
                <li>У самого <code>&lt;p&gt;</code>.</li>
                <li>Потім зовнішнього <code>&lt;div&gt;</code>.</li>
                <li>Потім зовнішнього <code>&lt;form&gt;</code>.</li>
                <li>І так далі вгору до об’єкта <code>document</code>.</li>
            </ul>
            <p>
                ⚠️ Майже всі події спливають. Ключове слово в цій фразі – “майже”. Наприклад, подія <code>focus</code> не спливає. Є й інші приклади, ми з ними познайомимося. Але все ж таки це скоріше виняток, ніж правило, більшість подій саме спливають.
            </p>

            <h2>Використання спливання подій</h2>
            <h3>Відправлення події до батьківського елемента</h3>
            <p>
                Однією з ключових можливостей спливання подій є здатність відправляти подію до батьківського елемента для обробки. Це корисно, коли вам потрібно забезпечити, що один обробник подій вистачить для групи елементів з однаковою функціональністю.
            </p>
            <pre>
        <code>
          {`
// HTML
<div id="parent">
    Батьківський елемент
    <button id="child">Дочірній елемент</button>
</div>
          `}
        </code>
      </pre>
            <pre>
        <code>
          {`
// JavaScript
const parent = document.getElementById("parent");
const child = document.getElementById("child");

parent.addEventListener("click", function (event) {
    alert("Обробник події на батьківському елементі");
});

child.addEventListener("click", function (event) {
    alert("Обробник події на дочірньому елементі");
    event.stopPropagation(); // Зупинка спливання події
});
          `}
        </code>
      </pre>
            <p>
                У цьому прикладі обробник події призначений для батьківського та дочірнього елемента. Коли ви клікаєте на дочірньому елементі, спочатку спрацьовує обробник для дочірнього елемента, а потім для батьківського. Однак, завдяки методу <code>stopPropagation()</code>, спливання події зупиняється, і обробник на батьківському елементі не спрацьовує.
            </p>

            <h2>Висновок</h2>
            <p>
                Спливання подій є потужним механізмом в JavaScript та DOM, який дозволяє обробляти події на батьківських елементах за умови, що вони були спровоковані на дочірньому елементі. Це полегшує роботу з подіями на веб-сторінках і дозволяє створювати більш компактний та підтримуваний код. Використовуючи спливання подій разом із методом <code>stopPropagation()</code>, ви можете точно керувати тим, як події розповсюджуються вгору по DOM-дереву, що забезпечує більш високий рівень контролю над вашими веб-додатками.
            </p>
        </div>
    );
};

export default EventBubblingPage;