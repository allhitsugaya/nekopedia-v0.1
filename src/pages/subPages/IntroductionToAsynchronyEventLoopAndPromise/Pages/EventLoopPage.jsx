import React from 'react';
import {Box, Container, List, ListItem} from "@mui/material";
import BookHeader from "../../../../features/BookHeader/BookHeader.jsx";
import Paragraph from "../../../../features/Paragraph/Paragraph.jsx";
import Code from "../../../../features/Code/Code.jsx";
import SubHeader from "../../../../features/SubHeader/SubHeader.jsx";
import CodeBlock from "../../../../features/CodeBlock/CodeBlock.jsx";
import Conclusion from "../../../../features/Conclusion/Conclusion.jsx";

const EventLoopPage = () => {
    return (
        <Container className="page-container">
            <BookHeader>Event Loop</BookHeader>
            <Paragraph>
                <Code>Event Loop</Code> (петля подій) - це механізм у багатьох мов програмування, включаючи JavaScript, який керує потоком виконання подій або запитів в програмі.
            </Paragraph>
            <Paragraph>
                Основна ідея Event Loop полягає в тому, що програма необхідно постійно очікувати на події або запити, які можуть виникнути асинхронно. Замість блокування виконання програми на очікуванні результату або відповіді, Event Loop дозволяє програмі продовжувати виконувати інші завдання, поки очікується на результат або подію.
            </Paragraph>
            <Paragraph>
                У JavaScript, Event Loop відповідає за обробку подій, таких як клік мишею, завантаження сторінки, отримання відповіді з сервера, таймери, тощо. Коли подія виникає, вона додається до черги подій. Event Loop постійно перевіряє цю чергу, виконуючи обробку подій в порядку їх надходження.
            </Paragraph>
            <Paragraph>
                Це дозволяє JavaScript використовувати асинхронні операції, такі як запити до сервера, без блокування виконання інших частин програми. Завдяки Event Loop, JavaScript може забезпечувати плавне та реагуюче взаємодію з користувачем, навіть при виконанні великих обчислень або завантаженні ресурсів.
            </Paragraph>

            <SubHeader>1. Яка ідея циклу подій?</SubHeader>
            <Paragraph>
                Існує нескінченний цикл подій, в якому JavaScript рушій чекає своє завдання, виконує його і чекає на нове. Алгоритм роботи рушія ми можемо бачити під час перегляду будь-якої веб-сторінки. Він входить у роботу тоді, коли необхідно обробити будь-яку подію чи скрипт. Схема роботи виглядає так:
            </Paragraph>
            <Paragraph>
                На початку JavaScript не діє і чекає на своє завдання. Але як тільки завдання з'являються, рушій починає їх виконання, починаючи з першого. Якщо надійшло нове завдання, але рушій зайнятий виконанням попереднього - воно ставиться в чергу.
            </Paragraph>

            <SubHeader>2. Основні частини можна описати так:</SubHeader>
            <Box sx={{ml:2}}>
                <List sx={{
                    pl: 2,
                    listStyleType: 'disc',
                    '& .MuiListItem-root': {
                        display: 'list-item',
                        py: 0.5,
                        pl: 1,
                        ml: 2,
                        fontSize: 14,
                        fontWeight: 800
                    }
                }}>
                <ListItem>
                    <Code>Call Stack (Стек):</Code> Являє собою потік виконання коду JavaScript. Event Loop виконує одне просте завдання – здійснює контроль стеку викликів та черги зворотних викликів. Якщо стек викликів порожній, цикл подій візьме першу подію з черги і відправить її в стек викликів, який запустить. При виклику нового способу зверху стека виділяється окремий блок пам'яті. Стек викликів відповідає за відстеження всіх операцій у черзі, які мають бути здійснені. При завершенні черги вона витягується зі стека.
                </ListItem>
                <ListItem>
                    <Code>Heap (Купа):</Code> Це область пам'яті, де розміщуються об'єкти. Куча не має строгого порядку і дозволяє динамічно виділяти і звільняти пам'ять для об'єктів.
                </ListItem>
                <ListItem>
                    <Code>Queue (Черга):</Code> Черга подій відповідає за надсилання нових функцій на трек обробки. Він слідує структурі даних черги, щоб підтримувати правильну послідовність, в якій всі операції повинні надійти на виконання. Якщо простіше, то це і є список завдань, які повинні вирушити на обробку і чекають на свій час.
                </ListItem>
                <ListItem>
                    <Code>Web API:</Code> Не є частиною JavaScript, вони створені на основі JS. Щоразу, коли викликається асинхронна функція, вона відправляється до API браузера. На основі команди, отриманої зі стеку викликів, API запускає власну однопотокову операцію.
                </ListItem>
                </List>
            </Box>

            <SubHeader>3. Як події додаються до черги</SubHeader>
            <Paragraph>
                Всі події в браузерах постійно додаються до черги, якщо вони відбулися або мають свій обробник. <Code>setTimeout</Code> може додавати подію в чергу не відразу, а після зазначеного часу. Якщо на даний момент у черзі немає подій, воно надійде в обробку відразу.
            </Paragraph>
            <Paragraph>
                Коли операція <Code>setTimeout</Code> обробляється в стеку, вона надсилається відповідному API, який чекає до вказаного часу, щоб відправити цю операцію в обробку. Середовище керує кількома паралельними циклами подій, наприклад для обробки викликів API. Веб-воркери також працюють у своєму циклі подій.
            </Paragraph>
            <Paragraph>
                Операція вирушає у чергу подій. Отже, у нас є циклічна схема для виконання асинхронних операцій на JavaScript. Сама мова є однопоточною, але API-інтерфейси браузера діють як окремі потоки.
            </Paragraph>
            <Paragraph>
                Цикл подій постійно перевіряє, чи стек викликів порожній. Якщо він порожній, нові функції додаються із черги подій. Якщо це не так, то поточний виклик функції.
            </Paragraph>
            <Paragraph>
                Давайте подивимося, як відкласти виконання функції доти, доки стек не очиститься.
            </Paragraph>
            <Paragraph>
                Приклад використання <Code>setTimeout(() =&gt; {}, 0)</Code> полягає в тому, щоб викликати функцію, але виконати її після виконання решти всіх функцій у коді. Приклад:
            </Paragraph>
            <CodeBlock>
          {`
const bar = () => console.log('bar')
const baz = () => console.log('baz')

const foo = () => {
  console.log('foo')
  setTimeout(bar, 0)
  baz()
}

foo()
          `}
            </CodeBlock>

            <Paragraph>
                При запуску коду спочатку викликається <Code>foo()</Code>. Усередині <Code>foo()</Code> ми спочатку викликаємо <Code>setTimeout</Code>, передаючи <Code>bar</Code> як аргумент, і інструктуємо його таким чином, щоб він запускався якнайшвидше, передаючи <Code>0</Code> як таймер. Потім ми викликаємо <Code>baz()</Code>.
            </Paragraph>
            <Paragraph>
                Порядок функцій у програмі:
            </Paragraph>
            <CodeBlock>
          {`
foo
baz
bar
          `}
            </CodeBlock>

            <SubHeader>4. Черга подій</SubHeader>
            <Paragraph>
                Під час виклику <Code>setTimeout()</Code>, браузер або Node.js запускають таймер. Після закінчення таймера (у нашому випадку ми встановили <Code>0</Code> як тайм-аут), функція зворотного виклику поміститься в чергу подій.
            </Paragraph>
            <Paragraph>
                Черга подій також є місцем, де ініційовані користувачем події (кліки мишею, введення з клавіатури та ін) розміщуються в чергу до того, як код зможе на них відреагувати.
            </Paragraph>
            <Paragraph>
                Event Loop надає пріоритет стеку викликів. Спочатку він обробляє все, що знаходить у стеку викликів, а коли там нічого не лишається, переходить до обробки черги подій.
            </Paragraph>
            <Paragraph>
                <Code>setTimeout</Code> з аргументом <Code>0</Code> не гарантує, що обробка буде виконана миттєво. Все залежить від того, скільки завдань зараз перебуває в черзі. У прикладі нижче "message" буде виведено швидше обробника <Code>callback_1</Code>. Пояснюється це тим, що затримка є мінімальним часом, необхідним середовищі на виконання запиту.
            </Paragraph>
            <CodeBlock>
          {`
(function () {
  console.log('start');
  setTimeout(function callback() {
    console.log('message from callback');
  });

  console.log('message');

  setTimeout(function callback_1() {
    console.log('message from callback_1');
  }, 0);

  console.log('finish');
})();

// "start"
// "message"
// "finish"
// "message from callback"
// "message from callback_1"
          `}
            </CodeBlock>

                <SubHeader>5. Заключення</SubHeader>
                <Paragraph>
                    Веб-сайти стали більш інтерактивними і динамічними, необхідність виконання інтенсивних операцій
                    стала більш актуальною (наприклад, виконання зовнішніх мережевих запитів для отримання даних API).
                    Щоб обробляти ці операції, потрібне використання методів асинхронного програмування. Вбудований
                    механізм Event Loop допомагає JavaScript обробляти асинхронний код.
                </Paragraph>
        </Container>
    );
};

export default EventLoopPage;